(defconst eval-py (. python eval))
(defconst map (. python map))
(defconst zip (. python zip))
(defconst next (. python next))
(defconst iter (. python iter))
(defconst stdin (. python sys stdin))
(defconst stdout (. python sys stdout))
(defconst stderr (. python sys stderr))
(defconst type-list (. python list))
(defconst type-tuple (. python tuple))
(defconst type-set (. python set))
(defconst type-dict (. python dict))
(defconst type-symbol (. adder common Symbol))
(defconst type-int (. python int))
(defconst gensym (. adder common gensym))

(defmacro dp (expr)
  (defvar scratch (gensym))
  (mk-list (quote scope)
           (mk-list (quote defvar) scratch expr)
           (mk-list (quote print)
                    (mk-list (quote quote) expr)
                    ":"
                    scratch)
           scratch))

(defun head (l)
  ([] l 0)
  )

(defun tail (l)
  (slice l 1)
  )

(defun reverse! (l)
  ((. l reverse))
  l)

(defun cons (h t)
  (+ (mk-list h) t))

(defmacro cond (&rest cases)
  (defun mk (cs)
    (if (not cs)
        none
        (mk-list (quote if)
                 (head (head cs))
                 (cons (quote begin) (tail (head cs)))
                 (mk (tail cs)))
        )
    )
  (mk cases)
  )

(defmacro .. (&rest parts)
  (mk-list (quote lambda)
           (quote (obj))
           (+ (mk-list (quote .)
                       (quote obj)
                       )
              (list parts)
              )
           )
  )

(defun list? (x) (isinstance x type-list))
(defun tuple? (x) (isinstance x type-tuple))
(defun set? (x) (isinstance x type-set))
(defun dict? (x) (isinstance x type-dict))
(defun symbol? (x) (isinstance x type-symbol))
(defun int? (x) (isinstance x type-int))

(defmacro let* (decls &rest body)
  (+ (mk-list (quote scope))
     (list (map (lambda (def)
                  (if (list? def)
                      (mk-list (quote defvar)
                               ([] def 0)
                               ([] def 1))
                      (mk-list (quote defvar)
                               def)
                      )
                  )
                decls)
           )
     (list body)
     )
  )

(defmacro let (decls &rest body)
  (defvar vars (list (map (lambda (def)
                            (if (list? def)
                                (head def)
                                def))
                          decls)))
  (defvar exprs (list (map (lambda (def)
                             (if (list? def)
                                 ([] def 1)
                                 none))
                           decls)))
  (defvar scratches (list (map gensym vars)))

  (defvar decl-scratches (list (map list (zip scratches exprs))))
  (defvar decl-vars (list (map list (zip vars scratches))))
  
  (+ (mk-list (quote let*)
              (+ decl-scratches
                 decl-vars))
     (list body)))

(defmacro define (name-and-maybe-args &rest body-or-value)
  (if (list? name-and-maybe-args)
      (+ (mk-list (quote defun)
                  (head name-and-maybe-args)
                  (tail name-and-maybe-args))
         (list body-or-value))
      (mk-list (quote defvar)
               name-and-maybe-args
               ([] body-or-value 0))))

(defun error (msg)
  (raise ((. python Exception) msg)))

(defmacro case (key &rest cases)
  (define value-var (gensym "value"))
  (cons (quote scope)
        (cons (mk-list (quote define)
                       value-var
                       key)
              (mk-list
               (cons (quote cond)
                     (list
                      (map (lambda (values-and-body)
                             (define values (head values-and-body))
                             (define body (tail values-and-body))
                             (define pred
                               (if (list? values)
                                   (mk-list (quote in)
                                            value-var
                                            (mk-list (quote quote)
                                                     values))
                                   (if (== values (quote otherwise))
                                       true
                                       (mk-list (quote ==)
                                                value-var
                                                values))))
                             (cons pred body))
                           cases)
                      )
                     )
               )
              )
        )
  )

(defmacro ecase (key &rest cases)
  (cons (quote case)
        (cons key
              (+ (list cases)
                 (mk-list (mk-list (quote otherwise)
                                   (mk-list (quote error)
                                            "Fell through ecase")))))))
(define (take i n)
  (:= i (iter i))
  (while (> n 0)
         (yield (next i))
         (:= n (- n 1))))
