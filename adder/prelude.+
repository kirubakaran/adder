(defconst eval-py (. python eval))
(defconst map (. python map))
(defconst zip (. python zip))
(defconst next (. python next))
(defconst iter (. python iter))
(defconst stdin (. python sys stdin))
(defconst stdout (. python sys stdout))
(defconst stderr (. python sys stderr))
(defconst type-list (. python list))
(defconst type-tuple (. python tuple))
(defconst type-set (. python set))
(defconst type-dict (. python dict))
(defconst type-symbol (. adder common Symbol))
(defconst type-int (. python int))
(defconst gensym (. adder common gensym))

(defmacro dp (expr)
  (defvar scratch (gensym))
  `(scope
    (defvar ,scratch ,expr)
    (print (quote ,expr) ":" ,scratch)
    ,scratch))

(defun head (l)
  ([] l 0)
  )

(defun tail (l)
  (slice l 1)
  )

(defun reverse! (l)
  ((. l reverse))
  l)

(defun cons (h t)
  (+ (mk-list h) t))

(defmacro cond (&rest cases)
  (defun mk (cs)
    (if (not cs)
        none
        `(if ,(head (head cs))
             (begin
               ,@(tail (head cs)))
             ,(mk (tail cs)))
        )
    )
  (mk cases)
  )

(defmacro .. (&rest parts)
  `(lambda (obj)
     (. obj ,@parts)))

(defun list? (x) (isinstance x type-list))
(defun tuple? (x) (isinstance x type-tuple))
(defun set? (x) (isinstance x type-set))
(defun dict? (x) (isinstance x type-dict))
(defun symbol? (x) (isinstance x type-symbol))
(defun int? (x) (isinstance x type-int))

(defmacro let* (decls &rest body)
  `(scope
    ,@(map (lambda (def)
             (if (list? def)
                 `(defvar ,([] def 0)
                    ,([] def 1))
                 `(defvar ,def)
                 )
             )
           decls)
    ,@body
    )
  )

(defmacro let (decls &rest body)
  (defvar vars (list (map (lambda (def)
                            (if (list? def)
                                (head def)
                                def))
                          decls)))
  (defvar exprs (list (map (lambda (def)
                             (if (list? def)
                                 ([] def 1)
                                 none))
                           decls)))
  (defvar scratches (list (map gensym vars)))

  (defvar decl-scratches (list (map list (zip scratches exprs))))
  (defvar decl-vars (list (map list (zip vars scratches))))

  `(let* (,@decl-scratches
          ,@decl-vars)
     ,@body))

(defmacro define (name-and-maybe-args &rest body-or-value)
  (if (list? name-and-maybe-args)
      (let ((name (head name-and-maybe-args))
            (args (tail name-and-maybe-args)))
        `(defun ,name ,args ,@body-or-value))
      `(defvar ,name-and-maybe-args ,(head body-or-value))))

(defun error (msg)
  (raise ((. python Exception) msg)))

(defmacro case (key &rest cases)
  (define value-var (gensym "value"))
  `(scope
    (define ,value-var ,key)
    (cond ,@(map (lambda (values-and-body)
                   (define values (head values-and-body))
                   (define body (tail values-and-body))
                   `(,(cond
                       ((list? values)
                        `(in ,value-var (quote ,values)))
                       ((== values (quote otherwise)) true)
                       (true `(== ,value-var ,values)))
                     ,@body))
                 cases)
          )
    )
  )

(defmacro ecase (key &rest cases)
  `(case ,key
     ,@cases
     (otherwise (error "Fell through ecase"))))

(define (take i n)
  (:= i (iter i))
  (while (> n 0)
         (yield (next i))
         (:= n (- n 1))))

(defmacro when (cond &rest body)
  `(if ,cond
       (begin ,@body)))

(defmacro unless (cond &rest body)
  `(if (not ,cond)
       (begin ,@body)))

(defmacro delay (expr)
  (let ((cache-sym (gensym "cache"))
        (cache-valid-p-sym (gensym "cache-valid-p")))
    `(let ((,cache-sym none) (,cache-valid-p-sym false))
       (lambda ()
         (unless ,cache-valid-p-sym
           (:= ,cache-sym ,expr)
           (:= ,cache-valid-p-sym true))
         ,cache-sym))))

(define (force promise)
  (promise))
