(defconst eval-py (. python eval))
(defconst map (. python map))
(defconst zip (. python zip))
(defconst next (. python next))
(defconst iter (. python iter))
(defconst stdin (. python sys stdin))
(defconst stdout (. python sys stdout))
(defconst stderr (. python sys stderr))
(defconst type-list (. python list))
(defconst type-tuple (. python tuple))
(defconst type-set (. python set))
(defconst type-dict (. python dict))
(defconst type-symbol (. adder common Symbol))
(defconst type-int (. python int))
(defconst gensym (. adder common gensym))

(defmacro dp (expr)
  (defvar scratch (gensym))
  `(scope
    (defvar ,scratch ,expr)
    (print (quote ,expr) ":" ,scratch)
    ,scratch))

(defun head (l)
  ([] l 0)
  )

(defun tail (l)
  (slice l 1)
  )

(defun reverse! (l)
  ((. l reverse))
  l)

(defun cons (h t)
  (+ (mk-list h) t))

(defmacro cond (&rest cases)
  (defun mk (cs)
    (if (not cs)
        none
        `(if ,(head (head cs))
             (begin
               ,@(tail (head cs)))
             ,(mk (tail cs)))
        )
    )
  (mk cases)
  )

(defmacro .. (&rest parts)
  `(lambda (obj)
     (. obj ,@parts)))

(defun list? (x) (isinstance x type-list))
(defun tuple? (x) (isinstance x type-tuple))
(defun set? (x) (isinstance x type-set))
(defun dict? (x) (isinstance x type-dict))
(defun symbol? (x) (isinstance x type-symbol))
(defun int? (x) (isinstance x type-int))

(defmacro let* (decls &rest body)
  `(scope
    ,@(map (lambda (def)
             (if (list? def)
                 `(defvar ,([] def 0)
                    ,([] def 1))
                 `(defvar ,def)
                 )
             )
           decls)
    ,@body
    )
  )

(defmacro let (decls &rest body)
  (defvar vars (list (map (lambda (def)
                            (if (list? def)
                                (head def)
                                def))
                          decls)))
  (defvar exprs (list (map (lambda (def)
                             (if (list? def)
                                 ([] def 1)
                                 none))
                           decls)))
  (defvar scratches (list (map gensym vars)))

  (defvar decl-scratches (list (map list (zip scratches exprs))))
  (defvar decl-vars (list (map list (zip vars scratches))))

  `(let* (,@decl-scratches
          ,@decl-vars)
     ,@body))

(defmacro define (name-and-maybe-args &rest body-or-value)
  (if (list? name-and-maybe-args)
      (let ((name (head name-and-maybe-args))
            (args (tail name-and-maybe-args)))
        `(defun ,name ,args ,@body-or-value))
      `(defvar ,name-and-maybe-args ,(head body-or-value))))

(defun error (msg)
  (raise ((. python Exception) msg)))

(defmacro case (key &rest cases)
  (define value-var (gensym "value"))
  (cons (quote scope)
        (cons (mk-list (quote define)
                       value-var
                       key)
              (mk-list
               (cons (quote cond)
                     (list
                      (map (lambda (values-and-body)
                             (define values (head values-and-body))
                             (define body (tail values-and-body))
                             (define pred
                               (if (list? values)
                                   (mk-list (quote in)
                                            value-var
                                            (mk-list (quote quote)
                                                     values))
                                   (if (== values (quote otherwise))
                                       true
                                       (mk-list (quote ==)
                                                value-var
                                                values))))
                             (cons pred body))
                           cases)
                      )
                     )
               )
              )
        )
  )

(defmacro ecase (key &rest cases)
  (cons (quote case)
        (cons key
              (+ (list cases)
                 (mk-list (mk-list (quote otherwise)
                                   (mk-list (quote error)
                                            "Fell through ecase")))))))
(define (take i n)
  (:= i (iter i))
  (while (> n 0)
         (yield (next i))
         (:= n (- n 1))))

(defmacro when (cond &rest body)
  (mk-list 'if cond (cons 'begin (list body))))

(defmacro unless (cond &rest body)
  (mk-list 'if (mk-list 'not cond) (cons 'begin (list body))))
