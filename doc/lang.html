<html>
<head>
<title>Adder language spec</title>
</head>

<body>
<h1>Adder language spec</h1>

<p>(This is a really early version, which assumes you know some Lisp.)
</p>

<h2>Overview</h2>

<p>Adder is a Lisp-1, meaning that function names are variable names,
as in Scheme.  By contrast, in a Lisp-2, such as Common Lisp or Emacs
Lisp, function names are a separate namespace, so that, in the
expression <code>(foo foo)</code>, the two <code>foo</code>s are
unrelated.  (Python also has a single namespace, while Ruby has two.
I sometimes think of Python as a Perl-1, and Ruby as a Perl-2.)  All
names must be defined before being used; setting a variable without
defining it is an error.  There are no Common Lisp-style packages; a
symbol is purely a name.
</p>

<p>Adder supports object field access via Python syntax: foo.bar.baz,
  for example.  There is also a Lispy syntax, as in (. foo bar baz),
  which you'll need when you want to access a field of an object
  that's not in a variable.
  In addition, .bar.baz is a function, so that (.bar.baz foo)
  is equivalent to foo.bar.baz.  This is so you can write functional
  code without having to write quite so many trivial lambdas.
  The equivalent Lispy syntax is (.. bar baz).
</p>

<p>All Python builtins are available as members of the object
named <code>python</code>; so, for example, (python.sum '(1 2 3)) is
legal Adder.
</p>

<p>Adder supports Common Lisp-style (defmacro).
</p>

<h2>Builtins</h2>

<h3>Special forms</h3>

<dl>
<dt>quote</dt>
<dt>import</dt>
<dt>if</dt>
<dt>while</dt>
<dt>break</dt>
<dt>continue</dt>
<dt>begin</dt>
<dt>yield</dt>
<dt>return</dt>
<dt>lambda</dt>
<dt>and</dt>
<dt>or</dt>
<dt>:=</dt>
<dt>.</dt>
<dt>class</dt>
<dt>defconst</dt>
<dt>defmacro</dt>
<dt><a name="scope">scope</a></dt>
<dd>Like <code>(begin)</code>, but introduces a new lexical scope.
  You probably want <a href="#let"><code>(let)</code></a> instead.
</dd>
</dl>

<h3>Functions</h3>

<dl>
<dt>==</dt>
<dt>!=</dt>
<dt>&lt;=</dt>
<dt>&lt;</dt>
<dt>&gt;=</dt>
<dt>&gt;</dt>
<dt>+</dt>
<dt>-</dt>
<dt>*</dt>
<dt>/</dt>
<dt>//</dt>
<dt>%</dt>
<dt>in</dt>
<dt>raise</dt>
<dt>print</dt>
<dt>gensym</dt>
<dt>[]</dt>
<dt>getattr</dt>
<dt>slice</dt>
<dt>list</dt>
<dt>tuple</dt>
<dt>set</dt>
<dt>dict</dt>
<dt>isinstance</dt>
<dt>mk-list</dt>
<dt>mk-tuple</dt>
<dt>mk-set</dt>
<dt>mk-dict</dt>
<dt>mk-symbol</dt>
<dt>reverse</dt>
<dt>eval</dt>
<dt>stdenv</dt>
<dt>exec-py</dt>
<dd>Somewhat limited, because the Adder compiler renames vars to keep
  them unambiguous (so that we can have multiple lexical scopes within
  the same function).  As a result, something like <code>(begin
  (defvar x 9) (exec-py "x=7") x)</code> will return 9, not 7, since
  the <code>x</code> in Adder is actually <code>x-1</code>, which gets
  translated into <code>__adder__x_002d1</code>.
</dd>
<dt>apply</dt>
<dt>load</dt>
<dd>TODO: make it work as a first-order function.  The problem at the
  moment seems to be that it loads into the wrong environment.  See
  test-compiler.py, CompileAndEvalTestCase._testOpFuncLoad().
</dd>
</dl>

<h3>Constants</h3>

<dl>
<dt>true</dt>
<dt>false</dt>
<dt>None</dt>
</dl>

<h2>Prelude</h2>

<h3>Constants</h3>

<dl>
<dt>stdin</dt>
<dt>stdout</dt>
<dt>stderr</dt>
<dt>type-list</dt>
<dt>type-tuple</dt>
<dt>type-set</dt>
<dt>type-dict</dt>
<dt>type-symbol</dt>
<dt>type-int</dt>
</dl>

<h3>Macros</h3>

<dl>
<dt>cond</dt>
<dt>case</dt>
<dt>ecase</dt>
<dt>..</dt>
<dd>A function generator.  <code>(.. bar baz)</code>
 is equivalent to <code>(lambda (x) (. x bar baz))</code>.
</dd>
<dt><a name="let">let</a></dt>
<dd>Yes, it can be defined in terms of lambda; but that depends on
  having cheap function calls.  I don't know that Python is cheap
  enough.  Instead I'm using rewriting to distinguish which scope a
  given var comes from.
</dd>
<dt>let*</dt>
<dt>define</dt>
<dd>Scheme-type syntax:
<code>(define (f x) (* x x))</code> or <code>(define y 9)</code>.
</dd>
<dt>delay, force</dt>
<dd>As in Scheme.</dd>
<dt>when, unless</dt>
<dd>As in Common Lisp.</dd>
<dt>with-macro-vars</dt>
<dd>(with-macro-vars (v1 ... vn) &rest body) binds v1 through vn to
  gensyms and evaluates body.</dd>
<dt>for</dt>
<dd>(for (var sequence) &rest body)</dd>
<dt>if-bind</dt>
<dd>(if-bind (var condition) then else): binds var to condition and
  then uses it in an if.
</dd>
<dt>when-bind</dt>
<dd>(when-bind (var condition) then): binds var to condition and
  then uses it in an when.
</dd>
</dl>


<h3>Functions</h3>

<dl>
<dt>error</dt>
<dt>reverse!</dt>
<dt>cons</dt>
<dt>list?</dt>
<dt>tuple?</dt>
<dt>set?</dt>
<dt>dict?</dt>
<dt>symbol?</dt>
<dt>int?</dt>
<dt>head</dt>
<dt>tail</dt>
<dt>eval-py</dt>
<dt>map</dt>
<dt>zip</dt>
<dt>take</dt>
<dd>Input: an iterator, i, and an integer, n.  Output: a generator
  which yields the next n elements of i.
<dt>str</dt>
<dt>len</dt>
</dl>

</body>
</html>
