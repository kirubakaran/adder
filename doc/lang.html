<html>
<head>
<title>Adder language spec</title>
</head>

<body>
<h1>Adder language spec</h1>

<h2>Overview</h2>

<p>Adder is a Lisp-1, meaning that function names are variable
names, as in Scheme, not a separate set of names, as in
Common Lisp.  (Python also has a single namespace, while Ruby has
two.  I sometimes think of Python as a Perl-1, and Ruby as a Perl-2.)
All names must be defined before being used; setting a
variable without binding it is an error.  There are no Common
Lisp-style packages; a symbol is purely a name.
</p>

<p>All Python builtins are available in the "python" package; so, for
example, (python.sum '(1 2 3)) is legal Adder.
</p>

<p>Adder supports Common Lisp-style (defmacro).
</p>

<p>Adder supports object field access via Python syntax: foo.bar.baz,
  for 
example.  In addition, .bar.baz is a function, so that (.bar.baz foo)
is equivalent to (foo.bar.baz).
</p>

<h2>Builtins</h2>

<h3>Special forms</h3>

<p>Implemented in Gomer:</p>

<dl>
<dt>quote</dt>
<dt>import</dt>
<dt>if</dt>
<dt>while</dt>
<dt>break</dt>
<dt>continue</dt>
<dt>begin</dt>
<dt>yield</dt>
<dt>return</dt>
<dt>lambda</dt>
<dt>and</dt>
<dt>or</dt>
<dt>:=</dt>
<dt>.</dt>
<dd>Adder <code>(. foo bar baz)</code> is equivalent to
  Python <code>foo.bar.baz</code>.
</dd>
</dl>

<p>Implemented in the Adder layer:</p>

<dl>
<dt>defmacro</dt>
</dl>

<h3>Functions</h3>

<p>Implemented in Gomer:</p>

<dl>
<dt>==</dt>
<dt>!=</dt>
<dt>&lt;=</dt>
<dt>&lt;</dt>
<dt>&gt;=</dt>
<dt>&gt;</dt>
<dt>+</dt>
<dt>-</dt>
<dt>*</dt>
<dt>/</dt>
<dt>//</dt>
<dt>%</dt>
<dt>in</dt>
<dt>raise</dt>
<dt>print</dt>
<dt>gensym</dt>
<dt>[]</dt>
<dt>getattr</dt>
<dt>slice</dt>
<dt>list</dt>
<dt>tuple</dt>
<dt>set</dt>
<dt>dict</dt>
<dt>isinstance</dt>
<dt>mk-list</dt>
<dt>mk-tuple</dt>
<dt>mk-set</dt>
<dt>mk-dict</dt>
<dt>mk-symbol</dt>
<dt>reverse</dt>
<dt>reverse!</dt>
<dt>eval</dt>
<dd>TODO: must wait for Adder-to-Gomer layer.</dd>
<dt>stdenv</dt>
<dt>eval-py</dt>
<dt>exec-py</dt>
<dt>apply</dt>
<dt>load</dt>
<dd>TODO: must wait for Adder-to-Gomer layer.</dd>
</dl>

<h3>Constants</h3>

<dl>
<dt>stdin</dt>
<dd>TODO</dd>
<dt>stdout</dt>
<dd>TODO</dd>
<dt>stderr</dt>
<dd>TODO</dd>
<dt>true</dt>
<dt>false</dt>
<dt>type-list</dt>
<dd>TODO</dd>
<dt>type-tuple</dt>
<dd>TODO</dd>
<dt>type-set</dt>
<dd>TODO</dd>
<dt>type-dict</dt>
<dd>TODO</dd>
</dl>

<h2>Prelude</h2>

<h3>Macros</h3>

<dl>
<dt>cond</dt>
<dd>TODO</dd>
<dt>case</dt>
<dd>TODO</dd>
<dt>ecase</dt>
<dd>TODO</dd>
<dt>..</dt>
<dd>TODO.  A function generator.  <code>(.. bar baz)</code>
 is equivalent to <code>(lambda (x) (. x bar baz))</code>.
</dd>
<dt>try</dt>
<dd>TODO</dd>
<dt>let</dt>
<dd>TODO.
Yes, it can be defined in terms of lambda; but that depends on
  having cheap function calls.  I don't know that Python is cheap
  enough.
</dd>
<dt>let*</dt>
<dd>TODO.  The underlying (scope) and (defvar) setup will probably
  make it easier to implement (let) on top of (let*), instead of the
  other way around.
</dd>
<dt>define</dt>
<dd>TODO.  Scheme-type syntax:
<code>(define (f x) (* x x))</code> or <code>(define y 9)</code>.
</dd>
</dl>


<h3>Functions</h3>

<dl>
<dt>list?</dt>
<dd>TODO</dd>
<dt>tuple?</dt>
<dd>TODO</dd>
<dt>set?</dt>
<dd>TODO</dd>
<dt>dict?</dt>
<dd>TODO</dd>
<dt>symbol?</dt>
<dd>TODO</dd>
<dt>int?</dt>
<dd>TODO</dd>
<dt>head</dt>
<dd>TODO</dd>
<dt>tail</dt>
<dd>TODO</dd>
</dl>

</body>
</html>
