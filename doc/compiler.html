<html>
<head>
<title>The Adder compiler</title>
</head>

<body>
<h1>The Adder compiler</h1>

<p>Adder doesn't expose a compilation step, but there is a compiler
  under the hood, translating Adder to Python.  (There was an earlier
  prototype which targeted Python bytecode; but Python bytecode
  changes too quickly.  The compiler needed substantial rework to
  target Python 3.1 instead of 3.0.)
</p>

<h2>The intermediate languages</h2>

<p>The Adder compiler uses three intermediate languages: Gomer, Reg,
  and Pyle.  Adder is reduced to Gomer, which is reduced to Reg, which
  is then transliterated to Pyle, which is then transliterated to
  Python.  I intend to fold the last two steps Real Soon Now.  Then
  the current Pyle will go away, and Reg will be renamed Pyle.
</p>

<h3>Gomer</h3>

<p>Gomer is actually a subset of Adder, a core language with no
  macros. Gomer expressions get built into ASTs, which are annotated
  with knowledge of lexical scopes (and probably other stuff,
  eventually).
</p>

<h4>Gomer special forms</h4>

<dl>
<dt>begin</dt>
<dt>import</dt>
<dt>defvar</dt>
<dt>defun</dt>
<dt>if</dt>
<dt>lambda</dt>
<dt>scope</dt>
<dt>quote</dt>
<dt>-gomer-try</dt>
<dd>Each except: clause takes just a single statement; multiple
  statements require a (begin).  Adder will need a macro to do that
  wrapping.
</dd>
<dt>while</dt>
<dt>break</dt>
<dt>continue</dt>
<dt>yield</dt>
<dt>return</dt>
<dt>and</dt>
<dd>TODO (done in Pyle)</dd>
<dt>or</dt>
<dd>TODO (done in Pyle)</dd>
<dt>:=</dt>
<dt>.</dt>
</dl>

<h4>Gomer functions</h4>

<dl>
<dt>raise</dt>
<dt>exec-py</dt>
<dt>print</dt>
<dt>==</dt>
<dt>!=</dt>
<dt>&lt;=</dt>
<dt>&lt;</dt>
<dt>&gt;=</dt>
<dt>&gt;</dt>
<dt>+</dt>
<dt>-</dt>
<dt>*</dt>
<dt>/</dt>
<dt>//</dt>
<dt>%</dt>
<dt>in</dt>
<dt>gensym</dt>
<dt>[]</dt>
<dt>getattr</dt>
<dt>slice</dt>
<dt>list</dt>
<dt>tuple</dt>
<dt>set</dt>
<dt>dict</dt>
<dt>isinstance</dt>
<dt>mk-list</dt>
<dt>mk-tuple</dt>
<dt>mk-set</dt>
<dt>mk-dict</dt>
<dt>mk-symbol</dt>
<dt>reverse</dt>
<dt>stdenv</dt>
<dd>TODO.  (Done, but wrong.)</dd>
<dt>apply</dt>
</dl>

<h3>Reg</h3>

<p>Reg is an IL loosely based on register-based instruction sets.  The
  main characteristic is that there are no function arguments which
  include function calls, to avoid the problems that arose when I was
  less careful about statements which appeared inside expressions.
  For example, the translation of
  <code>(if a (:= b ([] a 0)) None)</code>, as an expression, used to
  put the assignment statement before the if, which is obviously not
  the goal.
</p>

<p>In Reg, the
  only legal arguments to a function are constants and variable
  names.  Most statement arguments, such as the body of
  a <code>(while)</code>, are limited to single statements; to use
  multiple statements, wrap them in a <code>(begin)</code>&mdash;which
  is the only exception to this rule; obviously, it has to support
  multiple statement arguments.
</p>

<p>The syntax is as follows:</p>

<ul>
<li>symbol := [instance of adder.common.Symbol]</li>
<li>literal := [instance of int, str, float, or bool]</li>
<li>list := [instance of list]</li>
<li>var := $symbol</li>
<li>any := $var | $literal | $list</li>
<li>simple := $var | $literal</li>
<li>fcall := (:= $var ($var $simple*))
</li>
<li>assign := (:= $var $simple)
</li>
<li>return := (return $simple)
</li>
<li>yield := (yield $simple)
</li>
<li>try := (try $stmt (:$var $var $stmt)* (:finally $stmt)?)
</li>
<li>raise := (raise $var)
</li>
<li>reraise := (reraise)
</li>
<li>quote := (quote $any)
</li>
<li>if := (if $simple $stmt $stmt?)
</li>
<li>while := (while $simple $stmt)
</li>
<li>def := (def $var ($var*) $stmt)
</li>
<li>break := (break)
</li>
<li>continue := (continue)
</li>
<li>pass := (pass)
</li>
<li>begin := (begin $var*)
</li>
<li>import := (import $var)
</li>

<li>stmt := $return | $yield | $try | $raise
      | $if | $while | $def | $break | $continue | $pass | $begin
      | $fcall | $assign | $import
</li>
</ul>

<h4>Reducing Gomer to Reg</h4>

<p>Gomer is reduced to Reg via a series of reduction rules.  There's a
  default rule for Gomer functions; all other Gomer forms need their
  own rules.  Rules are implemented as subclasses of
  adder.gomer.Reducer.  The current state of rules:
</p>

<h5>Gomer special forms</h5>

<dl>
<dt>begin</dt>
<dt>import</dt>

<dt>defvar</dt>
<dd>TODO</dd>

<dt>defun</dt>
<dt>if</dt>
<dt>lambda</dt>

<dt>scope</dt>
<dd>TODO</dd>

<dt>quote</dt>

<dt>-gomer-try</dt>
<dd>TODO</dd>

<dt>while</dt>

<dt>break</dt>
<dt>continue</dt>

<dt>yield</dt>
<dd>TODO</dd>
<dt>return</dt>
<dd>TODO</dd>

<dt>and</dt>
<dd>TODO</dd>
<dt>or</dt>
<dd>TODO</dd>
<dt>:=</dt>

<dt>.</dt>
<dd>TODO</dd>
</dl>

<h5>Gomer functions</h5>

<dl>
<dt>raise</dt>
<dd>TODO</dd>

<dt>exec-py</dt>
<dd>TODO</dd>

<dt>print</dt>
<dd>TODO</dd>

<dt>==</dt>
<dd>TODO</dd>

<dt>!=</dt>
<dd>TODO</dd>

<dt>&lt;=</dt>
<dd>TODO</dd>

<dt>&lt;</dt>
<dd>TODO</dd>

<dt>&gt;=</dt>
<dd>TODO</dd>

<dt>&gt;</dt>
<dd>TODO</dd>

<dt>+</dt>
<dd>TODO</dd>

<dt>-</dt>
<dd>TODO</dd>

<dt>*</dt>
<dd>TODO</dd>

<dt>/</dt>
<dd>TODO</dd>

<dt>//</dt>
<dd>TODO</dd>

<dt>%</dt>
<dd>TODO</dd>

<dt>in</dt>
<dd>TODO</dd>

<dt>gensym</dt>
<dd>TODO</dd>

<dt>[]</dt>
<dd>TODO</dd>

<dt>getattr</dt>
<dd>TODO</dd>

<dt>slice</dt>
<dd>TODO</dd>

<dt>list</dt>
<dd>TODO</dd>

<dt>tuple</dt>
<dd>TODO</dd>

<dt>set</dt>
<dd>TODO</dd>

<dt>dict</dt>
<dd>TODO</dd>

<dt>isinstance</dt>
<dd>TODO</dd>

<dt>mk-list</dt>
<dd>TODO</dd>

<dt>mk-tuple</dt>
<dd>TODO</dd>

<dt>mk-set</dt>
<dd>TODO</dd>

<dt>mk-dict</dt>
<dd>TODO</dd>

<dt>mk-symbol</dt>
<dd>TODO</dd>

<dt>reverse</dt>
<dd>TODO</dd>

<dt>stdenv</dt>
<dd>TODO</dd>

<dt>apply</dt>
<dd>TODO</dd>

</dl>


<h3>Pyle</h3>

<p>Pyle (Python Lisplike Encoding) is an encoding of a subset of
  Python in Lispy data structures.  It doesn't need to encode all of
  Python; it just needs to be the subset that the Gomer compiler will
  emit.  I could write the compiler to emit Python directly; but
  emitting code as text always gets so chaotic.  This should be
  better.
</p>

<p>At this writing, the encoding currently called Pyle is being phased
  out, to be replaced by Reg.  To do this, Reg will need to get Pyle's
  utilities for emitting Python code in a structured fashion.  Once
  that's done, the old Pyle will go away, and Reg will be renamed
  Pyle.  For clarity, of course.
</p>

</body>
</html>
